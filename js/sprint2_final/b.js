// https://contest.yandex.ru/contest/22781/run-report/140683188/
const _readline = require('readline');
const _reader = _readline.createInterface({
    input: process.stdin
});

const _inputLines = [];
let _curLine = 0;

_reader.on('line', line => {
    _inputLines.push(line);
});

process.stdin.on('end', solve);

/*
-- ПРИНЦИП РАБОТЫ --
Функция реализует алгоритм вычисления выражений в обратной польской нотации (RPN) с использованием стека.

Все числа из входного массива последовательно добавляются в стек.
При встрече оператора из стека извлекаются два последних числа (для бинарных операций),
к ним применяется операция, и результат помещается обратно в стек.

Таким образом, стек всегда содержит промежуточные результаты вычислений,
а после обработки всех токенов в стеке остаётся итоговый результат.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Обратная польская нотация гарантирует, что порядок операций однозначно определяется
положением операторов относительно операндов.

Стек обеспечивает корректный доступ к операндам в порядке их поступления:
- Числа помещаются в стек в порядке появления
- При выполнении операции берутся два верхних числа (последние добавленные)
- Результат операции становится новым промежуточным значением

Это соответствует математическим правилам приоритета операций в RPN.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
O(n), где n - количество токенов во входном массиве. В худшем случае в стеке будет хранить половину
токенов (выражение, когда сначала идут операнды: 1 2 3 4 + + +), то есть O(n/2)
То есть решение требует O(n/2) ~ O(n)

Каждый токен обрабатывается ровно один раз:
- Для чисел - операция push (O(1))
- Для операторов - две операции pop и одна push (O(1))
- Все операции со стеком выполняются за константное время

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
O(n) в худшем случае, когда все токены - числа, которые помещаются в стек.

В среднем случае сложность меньше, так как промежуточные результаты
заменяют операнды в стеке при выполнении операций.
*/
function calculate(tokens) {
    // Ваше решение
    const RADIX = 10;
    let stack = [];

    for (const token of tokens) {
        if (isNaN(token)) {
            let result = 0;

            const right = stack.pop();
            const left = stack.pop()

            switch (token) {
                case '+':
                    result = left + right;
                    break;
                case '-':
                    result = left - right;
                    break;
                case '*':
                    result = left * right;
                    break;
                case '/':
                    result = Math.floor(left / right);
                    break;
            }

            stack.push(result);
        } else {
            stack.push(parseInt(token, RADIX))
        }
    }

    return stack.pop();
}

function solve() {
    const tokens = readLine();

    process.stdout.write(`${ calculate(tokens.split(' ')) }`);
}

function readLine() {
    const line = _inputLines[_curLine];
    _curLine++;
    return line;
}
